<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>学习杂记</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->
<link rel="stylesheet" name="wiz_tmp_editor_style" href="学习杂记_files/fonts_2.css"><link rel="stylesheet" name="wiz_tmp_editor_style" href="学习杂记_files/fonts_10.css"><link type="text/css" rel="stylesheet" id="wiz_code_highlight_link" href="学习杂记_files/wiz_code_highlight_8.css"><style id="wiz_custom_css">html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 15px;            padding: 1.33rem 1rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td, th {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;			        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><link rel="stylesheet"  name="wiz_tmp_editor_style" href="学习杂记_files/fonts_39.css"><link rel="stylesheet"  name="wiz_tmp_editor_style" href="学习杂记_files/fonts_39.css"></head>

<body spellcheck="false" ><h1>2017年2月5日10:57:22</h1><div><ol><li>全局变量中的基本数据类型可以不给初始化值。但是局部变量必须初始化</li><li>双等号==运算符在比较基本数据类型时，是比较其字节类型是否相同，例如int a=3；type b=3；a=b。在比较对象类型时，只比较两者是否指向同一对象。</li><li>equals（）函数比较两个对象类型是否相同<br></li><li>加强版for循环：for（String name:nameArray）{}</li><li>类型转换，将小的数据类型转成较大的数据类型可以直接赋值转换当将大的数据类型转换成较小的数据类型时，需使用强制类型转换或者使用java内置的类和方式</li><ol><li>Short.parseShort(String);</li><li>Integer.parseInt(String);</li><li>Long.parseLong(String);</li><li>Float.parseFloat(String);</li><li>Double.parseDouble(String);</li><li>Byte.parseByte(String);</li><li>Boolean.parseBoolean(String);</li><li></li></ol><li>ArrayList数组：</li><ol><li><div><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="typ">ArrayList</span><span class="pun">&lt;</span><span class="typ">Egg</span><span class="pun">&gt;</span><span class="pln"> myList </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ArrayList</span><span class="pun">&lt;</span><span class="typ">Egg</span><span class="pun">&gt;();</span><span class="pln"> </span><span class="com">//创建新的ArrayList对象</span></code></li><li class="L1"><code class="language-java"><span class="typ">Egg</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Egg</span><span class="pun">();</span></code></li><li class="L2"><code class="language-java"><span class="pln">myList</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="com">//此ArrayList会产生一个“盒子”来放Egg对象，可以指定索引值，例如myList.add(9,s)</span></code></li><li class="L3"><code class="language-java"><span class="typ">Egg</span><span class="pln"> b </span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Egg</span><span class="pun">();</span></code></li><li class="L4"><code class="language-java"><span class="pln">myList</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">b</span><span class="pun">);</span></code></li><li class="L5"><code class="language-java"><span class="kwd">int</span><span class="pln"> theSize </span><span class="pun">=</span><span class="pln"> myList</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="com">//查询大小</span></code></li><li class="L6"><code class="language-java"><span class="kwd">boolean</span><span class="pln"> isIn </span><span class="pun">=</span><span class="pln"> myList</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="com">//查询是否包含对象s</span></code></li><li class="L7"><code class="language-java"><span class="kwd">int</span><span class="pln"> idx </span><span class="pun">=</span><span class="pln"> myList</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="pln">b</span><span class="pun">);</span><span class="com">//查询对象b在数组的哪个地方，返回1</span></code></li><li class="L8"><code class="language-java"><span class="kwd">boolean</span><span class="pln"> empty </span><span class="pun">=</span><span class="pln"> myList</span><span class="pun">.</span><span class="pln">isEmpty</span><span class="pun">();</span><span class="com">//判断集合是否为空，返回false</span></code></li><li class="L9"><code class="language-java"><span class="pln">myList</span><span class="pun">,</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="com">//指定删除对象s</span></code></li></ol></pre></div><div><br></div></div></li></ol><li>子类会继承父类所有piblic或protected类型的实例变量和方法，但不会继承父类所有private类型的变量和方法（这类变量和方法对子类不可见）。</li><li>关键字abstract 定义一个抽象的类或者方法，改类不能创建为对象</li><li>o instanceof Dog //判断o是否是Dog类</li><li>interface 接口，不同于继承<br><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">interface</span><span class="pln"> </span><span class="typ">Pet</span><span class="pun">{</span></code></li><li class="L1"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> beFriendly</span><span class="pun">();</span></code></li><li class="L2"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> play</span><span class="pun">();</span></code></li><li class="L3"><code class="language-java"><span class="pun">}</span></code></li><li class="L4"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Dog</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Canine</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">Pet</span><span class="pun">{</span></code></li><li class="L5"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> beFrinendly</span><span class="pun">(){……};</span></code></li><li class="L6"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> play</span><span class="pun">(){……};</span></code></li><li class="L7"><code class="language-java"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> roam</span><span class="pun">(){……};</span></code></li><li class="L8"><code class="language-java"><span class="pun">}</span></code></li></ol></pre></div><div><br></div></li><li><div>使用super关键字可以在子类调用子类覆盖父类之前父类的方法</div></li><li>使用super关键字可以显式调用父类中的构造方法，但是必须放在开头。不加super也会优先调用父类的默认构造方法（不带参数的那个）。super一般用在调用父类带有参数的构造函数</li><li>使用this关键字可以调用同类的另一个构造函数</li><li>回收的原则：</li><ol><li>没有任何引用的对象</li><li>超出作用域范围</li></ol><li>静态（static）的方法不能调用同一类中非静态的方法和实例变量</li><li>静态变量对所有实例还说都是相同的</li><li>静态的final变量是常数，不能修改，但是未被初始化的可以在后续程序中进行初始化</li><li>final</li><ol><li>final修饰类时，代表该类不能被任何类继承</li><li>final修饰实例变量时，代表该实例变量不能被修改<span style="line-height: 1.6;">final修饰方法时，代表此方法不能被子类的方法所覆盖</span></li><li>final修饰方法的传入参数时，代表该变量不能在方法中修改</li></ol><li>基础数据类型与对象数据类型，基础数据类型都有对应的对象数据类型，两者可自有相互转换</li><li>使用关键字try{……}catch（）{……}关键字进行java的异常处理</li><li>抛出异常</li><li><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);">即内部类里可以直接访问外部类的方法和属性，反之不行</span><br></li><li><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);"><span style="font-variant-ligatures: normal;">定义成员内部类后，必须使用外部类</span><span style="font-variant-ligatures: normal;">对象来创建内部类对象，即&nbsp;</span><code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13.5px; padding: 2px 4px; color: rgb(199, 37, 78); border-radius: 4px; word-break: break-all; font-variant-ligatures: normal; background-color: rgb(249, 242, 244);">内部类 对象名 = 外部类对象.new 内部类();</code><br></span></li><li><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">　　<img src="学习杂记_files/0.1289178691804409.png" alt="访问范围" style="font-family: Helvetica, 'Hiragino Sans GB', 微软雅黑, 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif; line-height: 1.6;" class=""></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">内部类的主要作用如下：</p><ol style="box-sizing: border-box; margin-bottom: 16px; padding-left: 2em; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">内部类的方法可以直接访问外部类的所有数据，包括私有的数据</p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</p></li></ol><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">我们通过代码来详细学习一下内部类吧！</p><h4 id="-" style="box-sizing: border-box; font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 1.4; color: rgb(51, 51, 51); margin-top: 1em; margin-bottom: 16px; font-size: 1.25em; font-variant-ligatures: normal; orphans: 2; widows: 2;">成员内部类：</h4><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgb(204, 204, 204); border-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 245, 245);"><code class="lang-java hljs" style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: inherit; color: rgb(248, 248, 242); border-radius: 0px; white-space: pre-wrap; word-break: break-all; overflow-x: auto; background-color: rgb(35, 36, 31);"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">package</span> com.shiyanlou;

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//外部类People</span><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">public</span> <span class="hljs-class" style="box-sizing: border-box; font-size: 15px;"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(248, 248, 242); font-weight: 100;">People</span> </span>{
    <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">private</span> String name = <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116); font-size: 15px;">"LiLei"</span>;         <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//外部类的私有属性</span><span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//内部类Student</span><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">public</span> <span class="hljs-class" style="box-sizing: border-box; font-size: 15px;"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(248, 248, 242); font-weight: 100;">Student</span> </span>{
        String ID = <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116); font-size: 15px;">"20151234"</span>;               <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//内部类的成员属性</span><span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//内部类的方法</span><span class="hljs-function" style="box-sizing: border-box; font-size: 15px;"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">public</span> <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">void</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(166, 226, 46); font-weight: 100;">stuInfo</span><span class="hljs-params" style="box-sizing: border-box;">()</span></span>{
            System.out.println(<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116); font-size: 15px;">"访问外部类中的name："</span> + name);
            System.out.println(<span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116); font-size: 15px;">"访问内部类中的ID："</span> + ID);
        }
    }

    <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//测试成员内部类</span><span class="hljs-function" style="box-sizing: border-box; font-size: 15px;"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">public</span> <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">static</span> <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">void</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(166, 226, 46); font-weight: 100;">main</span><span class="hljs-params" style="box-sizing: border-box;">(String[] args)</span> </span>{
        People a = <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">new</span> People();     <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//创建外部类对象，对象名为a</span>
        Student b = a.new Student(); <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//使用外部类对象创建内部类对象，对象名为b</span>
        b.stuInfo();   <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//调用内部对象的suInfo方法</span>
    }
}
</code></pre><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">由此，我们可以知道，成员内部类的使用方法：</p><ol style="box-sizing: border-box; margin-bottom: 16px; padding-left: 2em; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符</p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）</p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">定义成员内部类后，必须使用外部类对象来创建内部类对象，即&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13.5px; padding: 2px 4px; color: rgb(199, 37, 78); border-radius: 4px; word-break: break-all; background-color: rgb(249, 242, 244);">内部类 对象名 = 外部类对象.new 内部类();</code></p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字</p></li></ol><h4 id="-" style="box-sizing: border-box; font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 1.4; color: rgb(51, 51, 51); margin-top: 1em; margin-bottom: 16px; font-size: 1.25em; font-variant-ligatures: normal; orphans: 2; widows: 2;">静态内部类：</h4><pre style="box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; color: rgb(51, 51, 51); border: 1px solid rgb(204, 204, 204); border-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 245, 245);"><code class="lang-java hljs" style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: inherit; color: rgb(248, 248, 242); border-radius: 0px; white-space: pre-wrap; word-break: break-all; overflow-x: auto; background-color: rgb(35, 36, 31);"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">package</span> com.shiyanlou;

<span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//外部类People</span><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">public</span> <span class="hljs-class" style="box-sizing: border-box; font-size: 15px;"><span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-weight: 100;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(248, 248, 242); font-weight: 100;">People</span> </span>{
    <span class="hljs-keyword" style="box-sizing: border-box; color: rgb(249, 38, 114); font-size: 15px; font-weight: 100;">private</span> String name = <span class="hljs-string" style="box-sizing: border-box; color: rgb(230, 219, 116); font-size: 15px;">"LiLei"</span>;         <span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">//外部类的私有属性</span><span class="hljs-comment" style="box-sizing: border-box; color: rgb(117, 113, 94); font-size: 15px;">/*外部类的静态变量。
Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。
/*
    static String ID = "510xxx199X0724XXXX"; 

    //静态内部类Student
    public static class Student {
        String ID = "20151234";               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println("访问外部类中的ID：" + People.ID);
            System.out.println("访问内部类中的ID：" + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        Student b = new Student();   //直接创建内部类对象，对象名为b
        b.stuInfo();                 //调用内部对象的suInfo方法
    }
}
</span></code></pre><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">静态内部类是 static 修饰的内部类，这种内部类的特点是：</p><ol style="box-sizing: border-box; margin-bottom: 16px; padding-left: 2em; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2;"><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">静态内部类不能直接访问外部类的非静态成员，但可以通过&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13.5px; padding: 2px 4px; color: rgb(199, 37, 78); border-radius: 4px; word-break: break-all; background-color: rgb(249, 242, 244);">new 外部类().成员</code>&nbsp;的方式访问</p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">如果外部类的静态成员与内部类的成员名称相同，可通过<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13.5px; padding: 2px 4px; color: rgb(199, 37, 78); border-radius: 4px; word-break: break-all; background-color: rgb(249, 242, 244);">类名.静态成员</code>访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13.5px; padding: 2px 4px; color: rgb(199, 37, 78); border-radius: 4px; word-break: break-all; background-color: rgb(249, 242, 244);">成员名</code>直接调用外部类的静态成员</p></li><li style="box-sizing: border-box; font-size: 15px;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">创建静态内部类的对象时，不需要外部类的对象，可以直接创建&nbsp;<code style="box-sizing: border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13.5px; padding: 2px 4px; color: rgb(199, 37, 78); border-radius: 4px; word-break: break-all; background-color: rgb(249, 242, 244);">内部类 对象名= new 内部类();</code></p></li></ol><h4 id="-" style="box-sizing: border-box; font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 1.4; color: rgb(51, 51, 51); margin-top: 1em; margin-bottom: 16px; font-size: 1.25em; font-variant-ligatures: normal; orphans: 2; widows: 2;">方法内部类</h4><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">　　方法内部类就是定义在外部类的方法中的内部类，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p><br><div style="color:gray"><small>来源：&nbsp;<a href="https://www.shiyanlou.com/courses/18/labs/101/document">https://www.shiyanlou.com/courses/18/labs/101/document</a></small></div></li><li><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">从字面意思我们就可以知道，内部类（ Inner Class ）就是定义在另外一个类里面的类，而包含内部类的类被称为外部类。</p></li><li>多态</li><ol><li>引用多态<div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="typ">Animal</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Animal</span><span class="pun">();</span><span class="pln">  </span><span class="com">//a是父类的引用指向的是本类的对象</span></code></li><li class="L1"><code class="language-java"></code></li><li class="L2"><code class="language-java"><span class="typ">Animal</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Dog</span><span class="pun">();</span><span class="pln"> </span><span class="com">//b是父类的引用指向的是子类的对象</span></code></li><li class="L3"><code class="language-java"><span class="com">//注意：我们不能使用一个子类的引用去指向父类的对象</span></code></li><li class="L3"><font color="#ff0000">//注意：对象b不能调用Dog类的独有方法，优先调用Dog类的重写方法。————父类设定接口函数的必要</font></li></ol></pre></div><div><br></div></li><li>方法多态</li><ol><li><div><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><code class="language-java"><span class="typ">Animal</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Animal</span><span class="pun">();</span><span class="pln">  </span><span class="com">//a是父类的引用指向的是本类的对象</span></code></li><li class="L1"><code class="language-java"><span class="typ">Animal</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Dog</span><span class="pun">();</span><span class="pln"> </span><span class="com">//b是父类的引用指向的是子类的对象</span></code></li><li class="L2"><code class="language-java"><span class="com">//这边是引用的多态</span></code></li><li class="L3"><code class="language-java"></code></li><li class="L4"><code class="language-java"></code></li><li class="L5"><code class="language-java"><span class="pln">a</span><span class="pun">.</span><span class="pln">bark</span><span class="pun">();</span><span class="pln">   </span><span class="com">//调用的是父类Animal的方法</span></code></li><li class="L6"><code class="language-java"></code></li><li class="L7"><code class="language-java"><span class="pln">b</span><span class="pun">.</span><span class="pln">bark</span><span class="pun">();</span><span class="pln">   </span><span class="com">//调用的是子类Dog重写的方法</span></code></li><li class="L8"><code class="language-java"><span class="com">//这便是方法的多态</span></code></li></ol></pre></div><div><div>注意：</div><div>&nbsp;</div><div>父类分引用指向子类对象时不可以调用子类独有的方法，只能调用继承或重写的方法</div><div>引用多态不能使用一个子类的引用去指向父类的对象</div></div></li></ol><li>多态引用类型转换</li><ol><li>一种引用类型转换是向上类型转换（隐式/自动类型转换），是小类型到大类型的转换（无风险）。另一种是向下类型转换（强制类型转换），是大类型到小类型（有风险）。<br></li><li><br></li></ol></ol></ol></div></body></html>