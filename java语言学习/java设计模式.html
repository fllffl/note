<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>java设计模式</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->
<link rel="stylesheet" name="wiz_tmp_editor_style" href="java设计模式_files/fonts_11.css"><link rel="stylesheet" name="wiz_tmp_editor_style" href="java设计模式_files/fonts_31.css"><style id="wiz_custom_css">html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 15px;            padding: 1.33rem 1rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td, th {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;			        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><link rel="stylesheet"  name="wiz_tmp_editor_style" href="java设计模式_files/fonts_37.css"></head>

<body spellcheck="false" >java设计模式的原则<div><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">1、开闭原则（Open Close Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">开闭原则的意思是：对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">2、里氏替换原则（Liskov Substitution Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">里氏替换原则是面向对象设计的基本原则之一。 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">3、依赖倒置原则（Dependence Inversion Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">4、接口隔离原则（Interface Segregation Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护的软件设计思想。它强调低依赖、低耦合。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">5、单一职责原则（Single Responsibility Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">一个实体应尽量少地与其他实体之间发生相互作用，应该使得系统功能模块相对独立。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要约束的是类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">6、最少知识原则（Demeter Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。</p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;"><span style="box-sizing: border-box; font-weight: 700;">7、合成复用原则（Composite Reuse Principle）</span></p><p style="box-sizing: border-box; margin-bottom: 16px; color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2;">合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量使用 组合/聚合 的方式，而不是使用继承。</p><br><div style="color:gray"><small>来源：&nbsp;<a href="https://www.shiyanlou.com/courses/100/labs/863/document">https://www.shiyanlou.com/courses/100/labs/863/document</a></small></div></div><div style="color:gray"><br></div><h1>工厂模式</h1><div>工厂模式是一个抽象工厂生产多种产品，工厂独立于产品之外，产品按继承关系，工厂通过继承约束生产行为。一个具体工厂生产一种东西</div><div>抽象工厂模式是多个抽象工厂生产类似的不同产品的组合，通过接口实现，产品嵌于工厂下方，通过接口约束工厂行为。一个具体工厂生产组合不同的多种东西<img src="java设计模式_files/userid46108labid867time1428915237612.png" border="0" style="line-height: 1.6;" class=""></div><div>&nbsp;</div><div>相同点：不同的工厂生产不同的东西。</div><h1>适配器模式</h1><div><img src="java设计模式_files/userid46108labid868time1429155811802.png" border="0"></div><div><h1>装饰者模式</h1><div>用来给一个对象添加新方法</div><div><br></div><div>&nbsp;<img src="java设计模式_files/userid46108labid874time1429070289993.png" border="0" style="line-height: 1.6;"></div><div><br></div><div>&nbsp;最后返回一个Girl</div></div><div>关于装饰者模式与适配器模式的区别：</div><div>&nbsp; &nbsp;&nbsp;<br></div><ul style="box-sizing: border-box; margin-bottom: 16px; padding-left: 2em; font-variant-ligatures: normal; orphans: 2; widows: 2;"><li style="color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 15px; box-sizing: border-box;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">1.关于新职责：适配器也可以在转换时增加新的职责，但其主要目的并不在此；而装饰者模式主要目的，就是给被装饰者增加新职责用的。</p></li><li style="color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 15px; box-sizing: border-box;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">2.关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统来说是不可见或者说不可用的；而装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。</p></li><li style="color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 15px; box-sizing: border-box;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">3.关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）；而装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。</p></li><li style="color: rgb(51, 51, 51); font-family: -apple-system, 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 15px; box-sizing: border-box;"><p style="box-sizing: border-box; margin-top: 16px; margin-bottom: 16px;">&nbsp;<br></p></li></ul><h1 style="orphans: 2; widows: 2;"><font color="#333333" face="-apple-system, Microsoft Yahei, Helvetica Neue, Helvetica, Arial, sans-serif"><br></font><font color="#333333" face="-apple-system, Microsoft Yahei, Helvetica Neue, Helvetica, Arial, sans-serif">监听者模式</font></h1><div style="orphans: 2; widows: 2;"><img src="java设计模式_files/userid46108labid878time1429080230133.png" border="0"></div><div style="orphans: 2; widows: 2;"><br><div>&nbsp;将观众添加到VideoSite中，当有剧情更新时，依次调用观众的方法。监听者是VideoSite</div></div></body></html>