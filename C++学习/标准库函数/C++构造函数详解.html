<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>C++构造函数详解</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->
<style id="wiz_custom_css">html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 15px;            padding: 1.33rem 1rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td, th {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;			        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><link rel="stylesheet"  name="wiz_tmp_editor_style" href="C++构造函数详解_files/fonts_22.css"></head>

<body spellcheck="false" ><pre id="best-content-2309967878" accuse="aContent" class="best-text mb-10" style="margin-top: 10px; margin-bottom: 10px; padding: 0px; font-family: 'Microsoft YaHei', arial, 'courier new', courier, 宋体, monospace; white-space: pre-wrap; word-wrap: break-word; font-size: 16px; line-height: 29px; color: rgb(51, 51, 51); min-height: 55px; background-color: rgb(255, 255, 255);">c++类的构造函数详解                        <br>一、 构造函数是干什么的<br>class Counter<br>{<br>public:<br>         // 类Counter的构造函数<br>         // 特点：以类名作为函数名，无返回类型<br>         Counter()<br>         {<br>                m_value = 0;<br>         }         <br>private:    <br>         // 数据成员<br>         int m_value;<br>}<br><br>       该类对象被创建时，编译系统对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作<br><br>eg:    Counter c1;<br>        编译系统为对象c1的每个数据成员(m_value)分配内存空间，并调用构造函数Counter( )自动地初始化对象c1的m_value值设置为0<br>故：<br>        构造函数的作用：初始化对象的数据成员。<br><br>二、 构造函数的种类<br><br>class Complex <br>{         <br>private :<br>        double    m_real;<br>        double    m_imag;<br>public:<br>        //    无参数构造函数<br>        // 如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做<br>        // 只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来<br>        Complex(void)<br>        {<br>             m_real = 0.0;<br>             m_imag = 0.0;<br>        }         <br>        //    一般构造函数（也称重载构造函数）<br>        // 一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）<br>        // 例如：你还可以写一个 Complex( int num)的构造函数出来<br>        // 创建对象时根据传入的参数不同调用不同的构造函数<br>        Complex(double real, double imag)<br>        {<br>             m_real = real;<br>             m_imag = imag;         <br>         }<br>        <br>        //    复制构造函数（也称为拷贝构造函数）<br>        //    复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中<br>        //    若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因请查询 有关 “浅拷贝” 、“深拷贝”的文章论述<br>        Complex(const Complex &amp; c)<br>        {<br>                // 将对象c中的数据成员值复制过来<br>                m_real = c.m_real;<br>                m_img    = c.m_img;<br>        }            <br>    <br>        // 类型转换构造函数，根据一个指定的类型的对象创建一个本类的对象<br>        // 例如：下面将根据一个double类型的对象创建了一个Complex对象<br>        Complex::Complex(double r)<br>        {<br>                m_real = r;<br>                m_imag = 0.0;<br>        }<br><br>        // 等号运算符重载<br>        // 注意，这个类似复制构造函数，将=右边的本类对象的值复制给等号左边的对象，它不属于构造函数，等号左右两边的对象必须已经被创建<br>        // 若没有显示的写=运算符重载，则系统也会创建一个默认的=运算符重载，只做一些基本的拷贝工作<br>        Complex &amp;operator=( const Complex &amp;rhs )<br>        {<br>                // 首先检测等号右边的是否就是左边的对象本，若是本对象本身,则直接返回<br>                if ( this == &amp;rhs ) <br>                {<br>                        return *this;<br>                }<br>                <br>                // 复制等号右边的成员到左边的对象中<br>                this-&gt;m_real = rhs.m_real;<br>                this-&gt;m_imag = rhs.m_imag;<br>                <br>               // 把等号左边的对象再次传出<br>               // 目的是为了支持连等 eg:    a=b=c 系统首先运行 b=c<br>               // 然后运行 a= ( b=c的返回值,这里应该是复制c值后的b对象)    <br>                return *this;<br>        }<br>};<br><br>下面使用上面定义的类对象来说明各个构造函数的用法：<br><br>void main()<br>{<br>        // 调用了无参构造函数，数据成员初值被赋为0.0<br>        Complex c1，c2;<br>        // 调用一般构造函数，数据成员初值被赋为指定值<br>        Complex c3(1.0,2.5);<br>        // 也可以使用下面的形式<br>        Complex c3 = Complex(1.0,2.5);        <br>        //    把c3的数据成员的值赋值给c1<br>        //    由于c1已经事先被创建，故此处不会调用任何构造函数<br>        //    只会调用 = 号运算符重载函数<br>        c1 = c3;        <br>        //    调用类型转换构造函数<br>        //    系统首先调用类型转换构造函数，将5.2创建为一个本类的临时对象，然后调用等号运算符重载，将该临时对象赋值给c1<br>        c2 = 5.2;        <br>       // 调用拷贝构造函数( 有下面两种调用方式) <br>        Complex c5(c2);<br>        Complex c4 = c2;  // 注意和 = 运算符重载区分,这里等号左边的对象不是事先已经创建，故需要调用拷贝构造函数，参数为c2<br>       <br>}<br>三、思考与测验<br>1. 仔细观察复制构造函数<br>        Complex(const Complex &amp; c)<br>        {<br>                // 将对象c中的数据成员值复制过来<br>                m_real = c.m_real;<br>                m_img = c.m_img;<br>        }            <br>为什么函数中可以直接访问对象c的私有成员？<br>2. 挑战题，了解引用与传值的区别<br>  Complex test1(const Complex&amp; c)<br>  {<br>          return c;<br>  }  <br>  Complex test2(const Complex c)<br>  {<br>         return c;<br>   }  <br>   Complex test3()<br>   {<br>          static Complex c(1.0,5.0);<br>          return c;<br>   }  <br>  Complex&amp; test4()<br>  {<br>         static Complex c(1.0,5.0);<br>         return c;<br>  }  <br>  void main()<br>  {<br>        Complex a,b;    <br>        // 下面函数执行过程中各会调用几次构造函数，调用的是什么构造函数？<br>    <br>       test1(a);<br>       test2(a);<br>     <br>       b = test3();<br>       b = test4();     <br>       test2(1.2);<br>       // 下面这条语句会出错吗？<br>       test1(1.2);     //test1( Complex(1.2 )) 呢？<br>  } <br>四、附录(浅拷贝与深拷贝 <br>       上面提到，如果没有自定义复制构造函数，则系统会创建默认的复制构造函数，但系统创建的默认复制构造函数只会执行“浅拷贝”，即将被拷贝对象的数据成员的 值一一赋值给新创建的对象，若该类的数据成员中有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同，delete该指针 时则会导致两次重复delete而出错。下面是示例：<br>【浅拷贝与深拷贝】 <br>#include &lt;iostream.h&gt;<br>#include &lt;string.h&gt;<br>class Person <br>{<br>public :        <br>        // 构造函数<br>        Person(char * pN)<br>        {<br>              cout &lt;&lt; "一般构造函数被调用 !\n";<br>              m_pName = new char[strlen(pN) + 1];<br>              //在堆中开辟一个内存块存放pN所指的字符串<br>              if(m_pName != NULL) <br>              {<br>                 //如果m_pName不是空指针，则把形参指针pN所指的字符串复制给它<br>                   strcpy(m_pName ,pN);<br>              }<br>        }                <br>        // 系统创建的默认复制构造函数，只做位模式拷贝<br>        Person(Person &amp; p)    <br>        { <br>                  //使两个字符串指针指向同一地址位置         <br>                 m_pName = p.m_pName;         <br>        }  <br>        ~Person( )<br>        {<br>                delete m_pName;<br>        }        <br>private :<br>        char * m_pName;<br>};<br>void main( )<br>{ <br>        Person man("lujun");<br>        Person woman(man); <br>        // 结果导致   man 和    woman 的指针都指向了同一个地址<br>        // 函数结束析构时<br>        // 同一个地址被delete两次<br>}<br>// 下面自己设计复制构造函数，实现“深拷贝”，即不让指针指向同一地址，而是重新申请一块内存给新的对象的指针数据成员<br>Person(Person &amp; chs);<br>{<br>         // 用运算符new为新对象的指针数据成员分配空间<br>         m_pName=new char[strlen(p.m_pName)+ 1];<br>         if(m_pName)         <br>         {<br>                 // 复制内容<br>                strcpy(m_pName ,chs.m_pName);<br>         } <br>        // 则新创建的对象的m_pName与原对象chs的m_pName不再指向同一地址了<br>}</pre><br><div style="color:gray"><small>来源：&nbsp;<a href="http://zhidao.baidu.com/link?url=FLpLz44EndNKJHPdIDG6jSaGh_nR8IghzyYmpS0CPnVkrx4lLtlbAhwuZwz5tvlBWIXYLX7UUC_IycZs5HS9Yq">http://zhidao.baidu.com/link?url=FLpLz44EndNKJHPdIDG6jSaGh_nR8IghzyYmpS0CPnVkrx4lLtlbAhwuZwz5tvlBWIXYLX7UUC_IycZs5HS9Yq</a></small></div></body></html>