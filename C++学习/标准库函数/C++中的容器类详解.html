<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>C++中的容器类详解</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->
<link rel="stylesheet"  name="wiz_tmp_editor_style" href="C++中的容器类详解_files/fonts_11.css"><style id="wiz_custom_css">html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 15px;            padding: 1.33rem 1rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td, th {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;			        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><link rel="stylesheet"  name="wiz_tmp_editor_style" href="C++中的容器类详解_files/fonts_11.css"></head>

<body spellcheck="false" ><h1 id="A.2Ble6YmA-" style="margin-top: 0px; margin-bottom: 0px; padding-bottom: 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7); background-color: rgb(255, 255, 255);"><span style="font-size: 18px;">一、STL容器类</span></h1><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STL(Standard Template Library)的六大组件：容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。其交互关系：容器通过空间配置器取得数据存储空间，空间配置器通过迭代器存取容器的内容，仿函数可以协助空间配置器完成不同的策略变化，配接器可以修饰或套接仿函数。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><img src="C++中的容器类详解_files/0.8739852420985699.png" alt="" style="border-style: none; border-width: initial;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C++中的容器类包括“顺序存储结构”和“关联存储结构”，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。<br></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><img src="C++中的容器类详解_files/0.005942797055467963.png" alt="" style="border-style: none; border-width: initial;"><br></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>1、vector</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 连续存储结构，每个元素在内存上是连续的；</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 支持高效的<strong>随机访问</strong>和在<strong>尾端插入/删除</strong>操作，但其他位置的插入/删除操作效率低下；</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>2、deque</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 连续存储结构，即其每个元素在内存上也是连续的，类似于vector，不同之处在于，deque提供了两级数组结构，第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 这样，deque除了具有vector的所有功能外，还支持高效的<strong>首端插入/删除</strong>操作。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>3、list</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 支持高效的<strong>随机插入/删除</strong>操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>4、vector -- list -- deque：</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; a、若需要随机访问操作，则选择vector；</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; b、若已经知道需要存储元素的数目， 则选择vector；</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; c、若需要随机插入/删除（不仅仅在两端），则选择list</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; d、<strong>只有</strong>需要在首端进行插入/删除操作的时候，才选择deque，否则都选择vector。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; e、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; f、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>5、capacity -- size</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; a、capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; b、size是容器当前存储的元素的数目。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; c、vector默认的容量初始值，以及增长规则是依赖于编译器的。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>6、用vector存储自定义类对象时，自定义类对象须满足：</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; a、有可供调用的无参构造函数（默认的或自定义的）；</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; b、有可用的拷贝赋值函数（默认的或自定义的）</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>7、迭代器iterator</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; a、vector与deque的迭代器支持算术运算，list的迭代器只能进行++/--操作，不支持普通的算术运算。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>以下为整个列表概述：</strong></p><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table cellpadding="0" border="1" width="100%" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><tbody><tr><td class=""><p align="left">标准容器类</p></td><td class=""><p align="left">说明</p></td></tr><tr style="height: 37px;"><td colspan="2" class=""><p align="left">顺序性容器</p></td></tr><tr><td class=""><p align="left">vector</p></td><td class=""><p align="left">从后面快速的插入与删除，直接访问任何元素</p></td></tr><tr><td><p align="left">deque</p></td><td class=""><p align="left">从前面或后面快速的插入与删除，直接访问任何元素</p></td></tr><tr><td><p align="left">list</p></td><td class=""><p align="left">双链表，从任何地方快速插入与删除</p></td></tr><tr><td colspan="2"><p align="left">关联容器</p></td></tr><tr><td class=""><p align="left">set</p></td><td class=""><p align="left">快速查找，不允许重复值</p></td></tr><tr><td><p align="left">multiset</p></td><td class=""><p align="left">快速查找，允许重复值</p></td></tr><tr><td><p align="left">map</p></td><td class=""><p align="left">一对多映射，基于关键字快速查找，不允许重复值</p></td></tr><tr><td><p align="left">multimap</p></td><td><p align="left">一对多映射，基于关键字快速查找，允许重复值</p></td></tr><tr><td colspan="2"><p align="left">容器适配器</p></td></tr><tr><td><p align="left">stack</p></td><td><p align="left">后进先出</p></td></tr><tr><td><p align="left">queue</p></td><td><p align="left">先进先出</p></td></tr><tr><td><p align="left">priority_queue</p></td><td><p align="left">最高优先级元素总是第一个出列</p></td></tr></tbody></table></div><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>所有标准库共有函数</strong></p><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table cellpadding="0" border="1" width="100%" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><tbody><tr><td><p align="left">默认构造函数</p></td><td><p align="left">提供容器默认初始化的构造函数。</p></td></tr><tr><td><p align="left">复制构造函数</p></td><td><p align="left">将容器初始化为现有同类容器副本的构造函数</p></td></tr><tr><td><p align="left">析构函数</p></td><td><p align="left">不再需要容器时进行内存整理的析构函数</p></td></tr><tr><td><p align="left">empty</p></td><td><p align="left">容器中没有元素时返回true,否则返回false</p></td></tr><tr><td><p align="left">max_size</p></td><td><p align="left">返回容器中最大元素个数</p></td></tr><tr><td><p align="left">size</p></td><td><p align="left">返回容器中当前元素个数</p></td></tr><tr><td><p align="left">operator=</p></td><td><p align="left">将一个容器赋给另一个容器</p></td></tr><tr><td><p align="left">operator&lt;</p></td><td><p align="left">如果第一个容器小于第二个容器，返回true，否则返回false，</p></td></tr><tr><td><p align="left">operator&lt;=</p></td><td><p align="left">如果第一个容器小于或等于第二个容器，返回true，否则返回false</p></td></tr><tr><td><p align="left">operator&gt;</p></td><td><p align="left">如果第一个容器大于第二个容器，返回true，否则返回false</p></td></tr><tr><td><p align="left">operator&gt;=</p></td><td><p align="left">如果第一个容器大于或等于第二个容器，返回true，否则返回false</p></td></tr><tr><td><p align="left">operator==</p></td><td><p align="left">如果第一个容器等于第二个容器，返回true，否则返回false</p></td></tr><tr><td><p align="left">operator!=</p></td><td><p align="left">如果第一个容器不等于第二个容器，返回true，否则返回false</p></td></tr><tr><td><p align="left">swap</p></td><td><p align="left">交换两个容器的元素</p></td></tr></tbody></table></div></div><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">其中operator&gt;,operator&gt;=,operator&lt;,operator&lt;=,operator==,operator!=均不适用于priority_queue</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>顺序容器和关联容器共有函数</strong></p><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table cellpadding="0" border="1" width="100%" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><tbody><tr><td><p align="left">begin</p></td><td><p align="left">该函数两个版本返回iterator或const_iterator，引用容器第一个元素</p></td></tr><tr><td><p align="left">end</p></td><td><p align="left">该函数两个版本返回iterator或const_iterator,引用容器最后一个元素后面一位</p></td></tr><tr><td><p align="left">rbegin</p></td><td><p align="left">该函数两个版本返回reverse_iterator或const_reverse_iterator,引用容器最后一个元素</p></td></tr><tr><td><p align="left">rend</p></td><td><p align="left">该函数两个版本返回reverse_iterator或const_reverse_iterator，引用容器第一个元素前面一位</p></td></tr><tr><td><p align="left">erase</p></td><td><p align="left">从容器中清除一个或几个元素</p></td></tr><tr><td><p align="left">clear</p></td><td><p align="left">清除容器中所有元素</p></td></tr></tbody></table></div></div><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下表显示了顺序容器和关联容器中常用的typedef，这些typedef常用于变量、参数和函数返回值的一般性声明。</p><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table cellpadding="0" border="1" width="100%" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><tbody><tr><td><p align="left">value_type</p></td><td><p align="left">容器中存放元素的类型</p></td></tr><tr><td><p align="left">reference</p></td><td><p align="left">容器中存放元素类型的引用</p></td></tr><tr><td><p align="left">const_reference</p></td><td><p align="left">容器中存放元素类型的常量引用，这种引用只能读取容器中的元素和进行const操作</p></td></tr><tr><td><p align="left">pointer</p></td><td><p align="left">容器中存放元素类型的指针</p></td></tr><tr><td><p align="left">iterator</p></td><td><p align="left">指向容器中存放元素类型的迭代器</p></td></tr><tr><td><p align="left">const_iterator</p></td><td><p align="left">指向容器中存放元素类型的常量迭代器，只能读取容器中的元素</p></td></tr><tr><td><p align="left">reverse_iterator</p></td><td><p align="left">指向容器中存放元素类型的逆向迭代器，这种迭代器在容器中逆向迭代</p></td></tr><tr><td><p align="left">const_reverse_iterator</p></td><td><p align="left">指向容器中存放元素类型的逆向迭代器，只能读取容器中的元素</p></td></tr><tr><td><p align="left">difference_type</p></td><td><p align="left">引用相同容器的两个迭代器相减结果的类型（list和关联容器没有定义operator-）</p></td></tr><tr><td><p align="left">size_type</p></td><td><p align="left">用于计算容器中项目数和检索顺序容器的类型（不能对list检索）</p></td></tr></tbody></table></div></div><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>8.序列类容器</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>(1)vector</strong>向量相当于一个数组</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacity（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; 优点：(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 随机访问方便，即支持[ ]操作符和vector.at()</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 节省空间。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; 缺点：(1) 在内部进行插入删除操作效率低。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>(2)list</strong>&nbsp;双向链表<strong></strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; 优点：(1) 不使用连续内存完成动态操作。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 在内部方便的进行插入和删除操作</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 可在两端进行push、pop</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; 缺点：(1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 相对于verctor占用内存多</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>(3) deque</strong>&nbsp;&nbsp; 双端队列 double-end queue</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; deque是在功能上合并了vector和list。</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; 优点：(1) 随机访问方便，即支持[ ]操作符和vector.at()</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 在内部方便的进行插入和删除操作</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 可在两端进行push、pop</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp; 缺点：(1) 占用内存多</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>使用区别：</strong></p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp; 1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p><p align="left" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp; 2）如果你需要<strong>大量</strong>的插入和删除，而不关心随机存取，则应使用list</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp; 3）如果你需要随机存取，而且关心<strong>两端</strong>数据的插入和删除，则应使用deque</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><img src="C++中的容器类详解_files/0.2605631756596267.png" alt="" style="border-style: none; border-width: initial;"></p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"></p><h1 id="A.2Ble6YmA-" style="margin-top: 0px; margin-bottom: 0px; padding-bottom: 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7); background-color: rgb(255, 255, 255);"><a name="t1" style="color: rgb(51, 102, 153);"></a><span style="font-size: 18px;">二、C++的STL算法</span></h1><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STL算法部分主要由头文件&lt;algorithm&gt;,&lt;numeric&gt;,&lt;functional&gt;组成。要使用 STL中的算法函数必须包含头文件&lt;algorithm&gt;，对于数值算法须包含&lt;numeric&gt;，&lt;functional&gt;中则定义了一些模板类，用来声明函数对象。<br>&nbsp;&nbsp;&nbsp; STL中算法大致分为四类：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、非可变序列算法：指不直接修改其所操作的容器内容的算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、可变序列算法：指可以修改它们所操作的容器内容的算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3、排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4、数值算法：对容器内容进行数值计算。</span><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"></span><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp; 以下对所有算法进行细致分类并标明功能：<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</strong><br>&nbsp;&nbsp;&nbsp; adjacent_find:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>&nbsp;&nbsp;&nbsp; binary_search:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>&nbsp;&nbsp;&nbsp; count:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>&nbsp;&nbsp;&nbsp; count_if:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>&nbsp;&nbsp;&nbsp; equal_range:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。<br>&nbsp;&nbsp;&nbsp; find:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。<br>&nbsp;&nbsp;&nbsp; find_end:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在指定范围内查找"由输入的另外一对iterator标志的第二个序列"的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的"另外一对"的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。<br>&nbsp;&nbsp;&nbsp; find_first_of:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在指定范围内查找"由输入的另外一对iterator标志的第二个序列"中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。<br>&nbsp;&nbsp;&nbsp; find_if:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用输入的函数代替等于操作符执行find。<br>&nbsp;&nbsp;&nbsp; lower_bound:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; upper_bound:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; search:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; search_n:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</strong><br>&nbsp;&nbsp;&nbsp; inplace_merge:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>&nbsp;&nbsp;&nbsp; merge:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>&nbsp;&nbsp;&nbsp; nth_element:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; partial_sort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; partial_sort_copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>&nbsp;&nbsp;&nbsp; partition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>&nbsp;&nbsp;&nbsp; random_shuffle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>&nbsp;&nbsp;&nbsp; reverse:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将指定范围内元素重新反序排序。<br>&nbsp;&nbsp;&nbsp; reverse_copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与reverse类似，不过将结果写入另一个容器。<br>&nbsp;&nbsp;&nbsp; rotate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>&nbsp;&nbsp;&nbsp; rotate_copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与rotate类似，不过将结果写入另一个容器。<br>&nbsp;&nbsp;&nbsp; sort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; stable_sort:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与sort类似，不过保留相等元素之间的顺序关系。<br>&nbsp;&nbsp;&nbsp; stable_partition:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与partition类似，不过不保证保留容器中的相对顺序。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;三&gt;删除和替换算法(15个)</strong><br>&nbsp;&nbsp;&nbsp; copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 复制序列<br>&nbsp;&nbsp;&nbsp; copy_backward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与copy相同，不过元素是以相反顺序被拷贝。<br>&nbsp;&nbsp;&nbsp; iter_swap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 交换两个ForwardIterator的值。<br>&nbsp;&nbsp;&nbsp; remove:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。<br>&nbsp;&nbsp;&nbsp; remove_copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>&nbsp;&nbsp;&nbsp; remove_if:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 删除指定范围内输入操作结果为true的所有元素。<br>&nbsp;&nbsp;&nbsp; remove_copy_if:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将所有不匹配元素拷贝到一个指定容器。<br>&nbsp;&nbsp;&nbsp; replace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将指定范围内所有等于vold的元素都用vnew代替。<br>&nbsp;&nbsp;&nbsp; replace_copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与replace类似，不过将结果写入另一个容器。<br>&nbsp;&nbsp;&nbsp; replace_if:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将指定范围内所有操作结果为true的元素用新值代替。<br>&nbsp;&nbsp;&nbsp; replace_copy_if:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与replace_if，不过将结果写入另一个容器。<br>&nbsp;&nbsp;&nbsp; swap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 交换存储在两个对象中的值。<br>&nbsp;&nbsp;&nbsp; swap_range:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将指定范围内的元素与另一个序列元素值进行交换。<br>&nbsp;&nbsp;&nbsp; unique:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; unique_copy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与unique类似，不过把结果输出到另一个容器。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</strong><br>&nbsp;&nbsp;&nbsp; next_permutation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; prev_permutation:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;<strong>&nbsp;&lt;五&gt;算术算法(4个)</strong><br>&nbsp;&nbsp;&nbsp; accumulate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。<br>&nbsp;&nbsp;&nbsp; partial_sum:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。<br>&nbsp;&nbsp;&nbsp; inner_product:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。<br>&nbsp;&nbsp;&nbsp; adjacent_difference:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;六&gt;生成和异变算法(6个)</strong><br>&nbsp;&nbsp;&nbsp; fill:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将输入值赋给标志范围内的所有元素。<br>&nbsp;&nbsp;&nbsp; fill_n:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将输入值赋给first到first+n范围内的所有元素。<br>&nbsp;&nbsp;&nbsp; for_each:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>&nbsp;&nbsp;&nbsp; generate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 连续调用输入的函数来填充指定的范围。<br>&nbsp;&nbsp;&nbsp; generate_n:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与generate函数类似，填充从指定iterator开始的n个元素。<br>&nbsp;&nbsp;&nbsp; transform:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;<strong>&nbsp;&lt;七&gt;关系算法(8个)</strong><br>&nbsp;&nbsp;&nbsp; equal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。<br>&nbsp;&nbsp;&nbsp; includes:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。<br>&nbsp;&nbsp;&nbsp; lexicographical_compare:&nbsp; 比较两个序列。重载版本使用用户自定义比较操作。<br>&nbsp;&nbsp;&nbsp; max:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回两个元素中较大一个。重载版本使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; max_element:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; min:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回两个元素中较小一个。重载版本使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; min_element:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; mismatch:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;<strong>&nbsp;&lt;八&gt;集合算法(4个)</strong><br>&nbsp;&nbsp;&nbsp; set_union:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; set_intersection:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; set_difference:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;九&gt;堆算法(4个)</strong><br>&nbsp;&nbsp;&nbsp; make_heap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>&nbsp;&nbsp;&nbsp; pop_heap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被"弹出"的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>&nbsp;&nbsp;&nbsp; push_heap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。<br>&nbsp;&nbsp;&nbsp; sort_heap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><strong>补充：</strong></p><div id="art" style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><p><strong>一、函数对象： 因为很多的算法中多使用了函数对象</strong><br>二元函数对象，V1和V2为输入，V3为结果</p><p>plus&lt;T&gt;:<br>&nbsp; transform(V1.begin(), V1.end(), V2.begin(), V3.begin(),plus&lt;double&gt;());</p><p>其他的二元函数对象：minus,multiples,divieds,modulus.</p><p>二元断言函数对象，使用时需要bind2nd（）或bind1st（）来绑定比较对象。</p><p>less&lt;T&gt;:<br>&nbsp; find_if(L.begin(), L.end(), bind2nd(less&lt;int&gt;(), 0));</p><p>其他的二元断言函数：equal_to,notequal_to,greater,greater_equal,less_equal,logical_and,logical_or</p><p>二元逻辑函数</p><p>binary_negate:<br>const char* wptr = find_if(str, str + MAXLEN,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compose2(not2(logical_or&lt;bool&gt;()),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind2nd(equal_to&lt;char&gt;(), ' '),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind2nd(equal_to&lt;char&gt;(), '/n')));</p><p>一元函数对象</p><p>negate：<br>transform(V1.begin(), V1.end(), V2.begin(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; negate&lt;int&gt;());</p><p>一元断定函数对象</p><p>logical_not:<br>&nbsp; transform(V.begin(), V.end(), V.begin(), logical_not&lt;bool&gt;());</p><p>一元逻辑函数</p><p>unary_negate:<br><strong>二、函数对象发生器：主要用来填充序列</strong><br>产生不重复的随机数：<br>// Generate unique random numbers from 0 to mod:<br>class URandGen {<br>&nbsp; std::set&lt;int&gt; used;<br>&nbsp; int limit;<br>public:<br>&nbsp; URandGen(int lim) : limit(lim) {<br>&nbsp;&nbsp;&nbsp; srand(time(0));<br>&nbsp; }<br>&nbsp; int operator()() {<br>&nbsp;&nbsp;&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i = int(rand()) % limit;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(used.find(i) == used.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used.insert(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>};</p><p>const int sz = 10;<br>const int max = 50;<br>vector&lt;int&gt; x(sz), y(sz), r(sz);<br>//An integer random number generator:<br>URandGen urg(max);<br>generate_n(x.begin(), sz, urg);</p><p><strong>三、函数对象适配器 ： 将函数转化为函数对象</strong></p><p>ptr_fun:一般函数适配器</p><p>一元实例：<br>transform(first, last, first,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compose1(negate&lt;double&gt;, ptr_fun(fabs)));</p><p>二元实例：<br>list&lt;char*&gt;::iterator item =&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find_if(L.begin(), L.end(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not1(binder2nd(ptr_fun(strcmp), "OK")));</p><p>not1：对一元的断定函数对象取反的适配器。</p><p>not2: 对二元的断定函数对象取反的适配器。</p><p>mem_fun与mem_fun_ref：类成员函数的适配器,区别是一个需要指针，而另一个仅需要一般对象。如下：<br>shape是一个指针变量，则foreach(v.begin(),v.end(),mem_fun(&amp;shape::draw));<br>但如果shape是一般的变量，不是指针，则foreach（v.begin(),v.end(),mem_fun_ref(&amp;shape::draw)）；</p><p><strong>四、算法</strong></p><p>拷贝：<br>copy（）<br>reverse_copy()<br>rotate_copy()<br>remove_copy()&nbsp; 拷贝不等于某值的元素到另一个序列。<br>remove_copy_if() 拷贝符合条件的到另一个序列。</p><p>填充和生成：<br>fill()<br>fill_n() 填充序列中的n个元素。<br>generate（）为序列中的每个元素调用gen（）函数。</p><p>排列：<br>next_permuttion() 后一个排列。<br>prev_permutation()</p><p>partition() 划分，将满足条件的元素移动到序列的前面。<br>stable_partition()</p><p>查找和替换：<br>find（）<br>binary_search() 在一个已经有顺序的序列上查找。<br>find_if()<br>search() 检查第二个序列是否在第一个序列中出现，且顺序相同。</p><p>删除：注意必须调用erase（）来真正删除<br>remove（）<br>unique（）删除相邻重复元素，最好现排序。</p><p>合并序列：<br>merge（）</p><p>数值算法：<br>accumulate（） 对序列的每个元素进行运算后求和。<br>transform（） 也可以对每个元素进行运算。<br>计数：<br>size（）总个数。<br>count（）等于某值的元素个数。</p><p>adjacent_difference 序列中的后一个减前与他相邻的前一个得到新的序列。</p><p>adiacent_find</p><p><strong>五、所有的算法</strong></p><p><span style="font-size: 10px;"><strong><span lang="EN-US"><span style="font-family: Tahoma;">accumlate</span>&nbsp;</span></strong>：&nbsp;<span lang="EN-US"><span style="font-family: Tahoma;">iterator</span>&nbsp;</span>对标志的序列中的元素之和，加到一个由&nbsp;<span lang="EN-US"><span style="font-family: Tahoma;">init</span>&nbsp;</span>指定的初始值上。重载的版本不再做加法，而是传进来的二元操作符被应用到元素上。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">adjacent_different</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：创建一个新序列，该序列的每个新值都代表了当前元素与上一个元素的差。重载版本用指定的二元操作计算相邻元素的差。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">adjacent_find</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：在&nbsp;<span lang="EN-US">iterator</span>&nbsp;对标志的元素范围内，查找一对相邻的重复元素，如果找到返回一个&nbsp;<span lang="EN-US">ForwardIterator</span>&nbsp;，指向这对元素的第一个元素。否则返回&nbsp;<span lang="EN-US">last</span>&nbsp;。重载版本使用输入的二元操作符代替相等的判断。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">binary_search</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：在有序序列中查找&nbsp;<span lang="EN-US">value</span>&nbsp;，如果找到返回&nbsp;<span lang="EN-US">true</span>&nbsp;。重载的版本使用指定的比较函数对象或者函数指针来判断相等。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：复制序列。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">copy_backward</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：除了元素以相反的顺序被拷贝外，别的和&nbsp;<span lang="EN-US">copy</span>&nbsp;相同。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">count</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：利用等于操作符，把标志范围类的元素与输入的值进行比较，并返回相等元素的个数。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">count_if</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：对于标志范围类的元素，应用输入的操作符，并返回结果为&nbsp;<span lang="EN-US">true</span>&nbsp;的次数。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">equal</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：如果两个序列在范围内的元素都相等，则&nbsp;<span lang="EN-US">equal</span>&nbsp;返回&nbsp;<span lang="EN-US">true</span>&nbsp;。重载版本使用输入的操作符代替了默认的等于操作符。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">equal_range</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：返回一对&nbsp;<span lang="EN-US">iterator</span>&nbsp;，第一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;表示由&nbsp;<span lang="EN-US">lower_bound</span>&nbsp;返回的&nbsp;<span lang="EN-US">iterator</span>&nbsp;，第二个表示由&nbsp;<span lang="EN-US">upper_bound</span>&nbsp;返回的<span lang="EN-US">iterator</span>&nbsp;值。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">fill</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将输入的值的拷贝赋给范围内的每个元素。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">fill_n</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将输入的值赋值给&nbsp;<span lang="EN-US">first</span>&nbsp;到&nbsp;<span lang="EN-US">frist+n</span>&nbsp;范围内的元素。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">find</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：利用底层元素的等于操作符，对范围内的元素与输入的值进行比较。当匹配时，结束搜索，返回该元素的一个&nbsp;<span lang="EN-US">InputIterator</span>&nbsp;。</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">find_if</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：使用输入的函数替代了等于操作符执行了&nbsp;<span lang="EN-US">find</span>&nbsp;。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">find_end</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：在范围内查找“由输入的另外一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;对标志的第二个序列”的最后一次出现。重载版本中使用了用户输入的操作符替代等于操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">find_first_of</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：在范围内查找“由输入的另外一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;对标志的第二个序列”中的任意一个元素的第一次出现。重载版本中使用了用户自定义的操作符。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">for_each</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：依次对范围内的所有元素执行输入的函数。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">generate</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：通过对输入的函数&nbsp;<span lang="EN-US">gen</span>&nbsp;的连续调用来填充指定的范围。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">generate_n</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：填充&nbsp;<span lang="EN-US">n</span>&nbsp;个元素。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">includes</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：判断&nbsp;<span lang="EN-US">[first1, last1)</span>&nbsp;的一个元素是否被包含在另外一个序列中。使用底层元素的&nbsp;<span lang="EN-US">&lt;=</span>&nbsp;操作符，重载版本使用用户输入的函数。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">inner_product</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：对两个序列做内积&nbsp;<span lang="EN-US">(</span>&nbsp;对应的元素相乘，再求和&nbsp;<span lang="EN-US">)</span>&nbsp;，并将内积加到一个输入的的初始值上。重载版本使用了用户定义的操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">inner_merge</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：合并两个排过序的连续序列，结果序列覆盖了两端范围，重载版本使用输入的操作进行排序。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">iter_swap</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：交换两个&nbsp;<span lang="EN-US">ForwardIterator</span>&nbsp;的值。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">lexicographical_compare</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：比较两个序列。重载版本使用了用户自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">lower_bound</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：返回一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;，它指向在范围内的有序序列中可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用了自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">max</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：返回两个元素中的较大的一个，重载版本使用了自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">max_element</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：返回一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;，指出序列中最大的元素。重载版本使用自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">min</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：两个元素中的较小者。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">min_element</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：类似与&nbsp;<span lang="EN-US">max_element</span>&nbsp;，不过返回最小的元素。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">merge</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：合并两个有序序列，并存放到另外一个序列中。重载版本使用自定义的比较。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">mismatch</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：并行的比较两个序列，指出第一个不匹配的位置，它返回一对&nbsp;<span lang="EN-US">iterator</span>&nbsp;，标志第一个不匹配的元素位置。如果都匹配，返回每个容器的&nbsp;<span lang="EN-US">last</span>&nbsp;。重载版本使用自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">next_permutation</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：取出当前范围内的排列，并将其重新排序为下一个排列。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">nth_element</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将范围内的序列重新排序，使所有小于第&nbsp;<span lang="EN-US">n</span>&nbsp;个元素的元素都出现在它前面，而大于它的都出现在后面，重载版本使用了自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">partial_sort</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：对整个序列做部分排序，被排序元素的个数正好可以被放到范围内。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">partial_sort_copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：与&nbsp;<span lang="EN-US">partial_sort</span>&nbsp;相同，除了将经过排序的序列复制到另外一个容器。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">partial_sum</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：创建一个新的元素序列，其中每个元素的值代表了范围内该位置之前所有元素之和。重载版本使用了自定义操作替代加法。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">partition</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：对范围内元素重新排序，使用输入的函数，把计算结果为&nbsp;<span lang="EN-US">true</span>&nbsp;的元素都放在结果为&nbsp;<span lang="EN-US">false</span>&nbsp;的元素之前。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">prev_permutation</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：取出范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回&nbsp;<span lang="EN-US">false</span>&nbsp;。重载版本使用自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">random_shuffle</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：对范围内的元素随机调整次序。重载版本输入一个随机数产生操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">remove</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：删除在范围内的所有等于指定的元素，注意，该函数并不真正删除元素。内置数组不适合使用&nbsp;<span lang="EN-US">remove</span>&nbsp;和&nbsp;<span lang="EN-US">remove_if</span>&nbsp;函数。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">remove_copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将所有不匹配的元素都复制到一个指定容器，返回的&nbsp;<span lang="EN-US">OutputIterator</span>&nbsp;指向被拷贝的末元素的下一个位置。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">remove_if</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：删除所有范围内输入操作结果为&nbsp;<span lang="EN-US">true</span>&nbsp;的元素。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">remove_copy_if</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将所有不匹配的元素拷贝到一个指定容器。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">replace</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将范围内的所有等于&nbsp;<span lang="EN-US">old_value</span>&nbsp;的元素都用&nbsp;<span lang="EN-US">new_value</span>&nbsp;替代。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">replace_copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：与&nbsp;<span lang="EN-US">replace</span>&nbsp;类似，不过将结果写入另外一个容器。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">replace_if</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将范围内的所有操作结果为&nbsp;<span lang="EN-US">true</span>&nbsp;的元素用新值替代。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">replace_copy_if</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：类似与&nbsp;<span lang="EN-US">replace_if</span>&nbsp;，不过将结果写入另外一个容器。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">reverse</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将范围内元素重新按反序排列。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">reverse_copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：类似与&nbsp;<span lang="EN-US">reverse</span>&nbsp;，不过将结果写入另外一个容器。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">rotate</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将范围内的元素移到容器末尾，由&nbsp;<span lang="EN-US">middle</span>&nbsp;指向的元素成为容器第一个元素。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">rotate_copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：类似与&nbsp;<span lang="EN-US">rotate</span>&nbsp;，不过将结果写入另外一个容器。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">search</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：给出了两个范围，返回一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;，指向在范围内第一次出现子序列的位置。重载版本使用自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">search_n</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：在范围内查找&nbsp;<span lang="EN-US">value</span>&nbsp;出现&nbsp;<span lang="EN-US">n</span>&nbsp;次的子序列。重载版本使用自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">set_difference</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：构造一个排过序的序列，其中的元素出现在第一个序列中，但是不包含在第二个序列中。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">set_intersection</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：构造一个排过序的序列，其中的元素在两个序列中都存在。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">set_symmetric_difference</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：构造一个排过序的序列，其中的元素在第一个序列中出现，但是不出现在第二个序列中。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">set_union</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：构造一个排过序的序列，它包含两个序列中的所有的不重复元素。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">sort</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：以升序重新排列范围内的元素，重载版本使用了自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">stable_partition</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：与&nbsp;<span lang="EN-US">partition</span>&nbsp;类似，不过它不保证保留容器中的相对顺序。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">stable_sort</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：类似与&nbsp;<span lang="EN-US">sort</span>&nbsp;，不过保留相等元素之间的顺序关系。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">swap</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：交换存储在两个对象中的值。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">swap_range</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将在范围内的元素与另外一个序列的元素值进行交换。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">transform</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：将输入的操作作用在范围内的每个元素上，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定的容器。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">unique</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：清除序列中重复的元素，和&nbsp;<span lang="EN-US">remove</span>&nbsp;类似，它也不能真正的删除元素。重载版本使用了自定义的操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">unique_copy</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：类似与&nbsp;<span lang="EN-US">unique</span>&nbsp;，不过它把结果输出到另外一个容器。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">upper_bound</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：返回一个&nbsp;<span lang="EN-US">iterator</span>&nbsp;，它指向在范围内的有序序列中插入&nbsp;<span lang="EN-US">value</span>&nbsp;而不破坏容器顺序的最后一个位置，该位置标志了一个大于&nbsp;<span lang="EN-US">value</span>&nbsp;的值。重载版本使用了输入的比较操作。&nbsp;</span><span lang="EN-US"><br></span><span style="font-family: Tahoma;">堆算法：&nbsp;<span lang="EN-US">C++</span>&nbsp;标准库提供的是&nbsp;<span lang="EN-US">max-heap</span>&nbsp;。一共由以下&nbsp;<span lang="EN-US">4</span>&nbsp;个泛型堆算法。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">make_heap</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：把范围内的元素生成一个堆。重载版本使用自定义的比较操作。</span>&nbsp;<span lang="EN-US"><br><strong><span style="font-family: Tahoma;">pop_heap</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：并不是真正的把最大元素从堆中弹出，而是重新排序堆。它把&nbsp;<span lang="EN-US">first</span>&nbsp;和&nbsp;<span lang="EN-US">last-1</span>&nbsp;交换，然后重新做成一个堆。可以使用容器的&nbsp;<span lang="EN-US">back</span>&nbsp;来访问被“弹出“的元素或者使用&nbsp;<span lang="EN-US">pop_back</span>&nbsp;来真正的删除。重载版本使用自定义的比较操作。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">push_heap</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：假设&nbsp;<span lang="EN-US">first</span>&nbsp;到&nbsp;<span lang="EN-US">last-1</span>&nbsp;是一个有效的堆，要被加入堆的元素在位置&nbsp;<span lang="EN-US">last-1</span>&nbsp;，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较。&nbsp;</span><span lang="EN-US"><br><strong><span style="font-family: Tahoma;">sort_heap</span>&nbsp;</strong></span><span style="font-family: Tahoma;">：对范围内的序列重新排序，它假设该序列是个有序的堆。重载版本使用自定义的比较操作</span></p></div><h1 id="A.2Ble6YmA-" style="margin-top: 0px; margin-bottom: 0px; padding-bottom: 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7); background-color: rgb(255, 255, 255);"><a name="t2" style="color: rgb(51, 102, 153);"></a><span style="font-size: 18px;">三、Qt容器类</span></h1><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Qt容器类的分类：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">1.连续容器：QVector、QLinkedList、QList、QStack（继承QVector）、 QQueue（继承QList）</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">2.关联容器：QSet、QMap、QMultiMap、QHash、QMultiHash</p><h3 style="margin-top: 0px; margin-bottom: 0px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; background-color: rgb(255, 255, 255);"><a name="t3" style="color: rgb(51, 102, 153);"></a>连续容器：</h3><span style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; font-size: 12px; background-color: rgb(255, 255, 255);"></span><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QVector&lt;T&gt; &nbsp;<br>它是QT里最常见的容器类，它对应STL中的Vector&lt;T&gt;容器，是动态数组，提供快速的索引存取。</span><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"></span><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QList&lt;T&gt;&nbsp;&nbsp;QLinkList&lt;T&gt;&nbsp;&nbsp;QVarLengthArray&lt;T&gt;提供类似的功能。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">可以参考帮助文档，查看QList的具体使用方法，以下列出部分使用示例：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">1.创建各种类型的vector：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;int&gt;&nbsp;integerVector;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;stringVector;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">2.创建一定数目项的vector</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector(200);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">3.带初始化的创建vector</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector(200,&nbsp;"Pass");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">也可以使用fill赋值：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector(3);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.fill("Yes");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;vector:&nbsp;["Yes",&nbsp;"Yes",&nbsp;"Yes"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.fill("oh",&nbsp;5);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;vector:&nbsp;["oh",&nbsp;"oh",&nbsp;"oh",&nbsp;"oh",&nbsp;"oh"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">4.QVector像c++的Vector一样提供[]下标操作，并从0项开始。还提供at()的只读操作,at()比[]更快，因为它不会导致深度复制。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;if&nbsp;(vector[0]&nbsp;==&nbsp;"Liz")</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector[0]&nbsp;=&nbsp;"Elizabeth";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;vector.size();&nbsp;++i)&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(vector.at(i)&nbsp;==&nbsp;"Alfonso")</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"Found&nbsp;Alfonso&nbsp;at&nbsp;position&nbsp;"&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;endl;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">5.你可以使用indexOf，lastIndexOf来查询获取某项值的索引：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector&nbsp;&lt;&lt;&nbsp;"A"&nbsp;&lt;&lt;&nbsp;"B"&nbsp;&lt;&lt;&nbsp;"C"&nbsp;&lt;&lt;&nbsp;"B"&nbsp;&lt;&lt;&nbsp;"A";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.indexOf("B");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;1</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.indexOf("B",&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;1</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.indexOf("B",&nbsp;2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;3</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.indexOf("X");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;-1</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.lastIndexOf("B");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;3</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.lastIndexOf("B",&nbsp;3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;3</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.lastIndexOf("B",&nbsp;2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;1</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.lastIndexOf("X");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;returns&nbsp;-1</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">也可以用contains()查看是否包含某元素，返回bool值。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">6.通过append，operator&lt;&lt;，prepend，insert添加元素。（对于较大的vector来说，在开头和中间插入项都是相当耗时的。这种情况更适合使用QLinkedList&lt;T&gt;）</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector(0);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.append("one");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.append("two");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.append("three");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;vector:&nbsp;["one",&nbsp;"two",&nbsp;"three"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector(0);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector&nbsp;&lt;&lt;&nbsp;“one”&nbsp;&lt;&lt;&nbsp;“two”&nbsp;&lt;&lt;&nbsp;“three”;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;vector:&nbsp;["one",&nbsp;"two",&nbsp;"three"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.prepend("one");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.prepend("two");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.prepend("three");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;vector:&nbsp;["three",&nbsp;"two",&nbsp;"one"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;QString&gt;&nbsp;vector;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector&nbsp;&lt;&lt;&nbsp;"alpha"&nbsp;&lt;&lt;&nbsp;"beta"&nbsp;&lt;&lt;&nbsp;"delta";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector.insert(2,&nbsp;"gamma");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;vector:&nbsp;["alpha",&nbsp;"beta",&nbsp;"gamma",&nbsp;"delta"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">7.size()&nbsp;resize()&nbsp;isEmpty()&nbsp;capacity()等和容器大小相关操作。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">8.相关转化：toList()&nbsp;&nbsp;toStdVector()&nbsp;&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;double&gt;&nbsp;vect;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vect&nbsp;&lt;&lt;&nbsp;"red"&nbsp;&lt;&lt;&nbsp;"green"&nbsp;&lt;&lt;&nbsp;"blue"&nbsp;&lt;&lt;&nbsp;"black";&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QList&lt;double&gt;&nbsp;list&nbsp;=&nbsp;vect.toList();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;//&nbsp;list:&nbsp;["red",&nbsp;"green",&nbsp;"blue",&nbsp;"black"]</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QVector&lt;double&gt;&nbsp;vector;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;vector&nbsp;&lt;&lt;&nbsp;1.2&nbsp;&lt;&lt;&nbsp;0.5&nbsp;&lt;&lt;&nbsp;3.14;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;std::vector&lt;double&gt;&nbsp;stdvector&nbsp;=&nbsp;vector.toStdVector();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">（以下容器操作函数的使用将不再累述，和查阅帮助文档，并且和QVector的使用方法是一样的。）</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QLinkedList&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">前面提到，它适合随机插入项，其原因是它的链式结构。他提供了常量时间的插入删除，却不能提供快速的随机存取操作。不提供[]操作，它的遍历元素是通过迭代器完成的。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QList&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">它是个数组列表，结合了上面两种结构的优点，它支持随机存取，在它的任意一端插入和删除都是非常快速的并且对于千项以上的列表，在中间插入和删除也是很快的。学过数据结构的都会清楚这三者的结构区别。如果非要每个项元素都相邻那就只能用QVector。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QString&lt;t&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">它是QList&lt;QString&gt;的子类，它为字符串操作提供了更通用的操作。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QStack&lt;T&gt;&nbsp;QQueue&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">他们是栈和队列结构的实现，QStack提供pop()&nbsp;push()&nbsp;swap()&nbsp;top()操作，它继承自QVector&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QQueue&lt;T&gt;提供dequeue()&nbsp;enqueue()&nbsp;head()&nbsp;swap操作。继承自QList&lt;T&gt;。</p><h2 style="margin-top: 0px; margin-bottom: 0px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; background-color: rgb(255, 255, 255);"><a name="t4" style="color: rgb(51, 102, 153);"></a>关联容器</h2><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QSet&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">它提供一个键值对集合，可以快速的进行查找，</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QMap&lt;Key,&nbsp;T&gt;&nbsp;QMultiMap&lt;Key,&nbsp;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QMap是一个以升序键顺序存储键值对的数据结构，QMultiMap是QMap基础上提供可以存储多值的maps，这样就是说一个键对应多个值了。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面是创建一个QString-int的maps</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMap&lt;QString,&nbsp;int&gt;&nbsp;map;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">可以这样插入值</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map["one"]&nbsp;=&nbsp;1;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map["three"]&nbsp;=&nbsp;3;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map["seven"]&nbsp;=&nbsp;7;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">也可以这样：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map.insert("twelve",&nbsp;12);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">查询一个值使用[]&nbsp;或者value(“**”)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;int&nbsp;num1&nbsp;=&nbsp;map["thirteen"];</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;int&nbsp;num2&nbsp;=&nbsp;map.value("thirteen");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">查询是否存在一个值：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;if&nbsp;(map.contains("TIMEOUT"))</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout&nbsp;=&nbsp;map.value("TIMEOUT");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">一般推荐使用contains()&nbsp;value()而不是[]。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QHash&lt;Key,&nbsp;T&gt;&nbsp;QMultiHash&lt;Key,&nbsp;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QHash&lt;Key,&nbsp;T&gt;是个在哈希表中存储键值对的结构。它的接口几乎和QMap相同，但它提供了更快的查找功能。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QHash为它的内部哈希表自动分配最初的存储区域，并在有项被插入或者删除时重新划分所分配的区域大小。也可以调用reserve()或者squeeze()来指定或者压缩希望存储到哈希表的项的数目，以进行性能调整。通常的做法是利用我们预期的最大的项的数目来调用reserve()，然后插入数据，最后如果有多出的项，则调用squeeze()以使内存减到最小。</p><h2 style="margin-top: 0px; margin-bottom: 0px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; background-color: rgb(255, 255, 255);"><a name="t5" style="color: rgb(51, 102, 153);"></a>迭代器</h2><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">对于每种容器都有两种风格的迭代器——java风格和STL风格。Java风格的更易于使用而以很少量性能作为了代价，而STL风格的可以结合STL的算法从而更加强大。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">这里我们主讲QList和QMap的迭代器为例。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Java-Style：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Java风格的迭代器分为两种：只读迭代器，读写迭代器。只读迭代器就是Q*Iterator&lt;T&gt;&nbsp;(例如QVectorIterator&lt;T&gt;)，而读写迭代器则像QMutable*Iterator&lt;T&gt;这种（例如：QMutableVectorIterator&lt;T&gt;）。</p><div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table><tbody><tr><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Containers</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Read-only&nbsp;iterator</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Read-write&nbsp;iterator</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QList</a>&lt;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QQueue</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QListIterator</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMutableListIterator</a>&lt;T&gt;</p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QLinkedList</a>&lt;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QLinkedListIterator</a>&lt;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMutableLinkedListIterator</a>&lt;T&gt;</p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QVector</a>&lt;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QStack</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QVectorIterator</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMutableVectorIterator</a>&lt;T&gt;</p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QSet</a>&lt;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QSetIterator</a>&lt;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMutableSetIterator</a>&lt;T&gt;</p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMap</a>&lt;Key,&nbsp;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMultiMap</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMapIterator</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMutableMapIterator</a>&lt;Key,&nbsp;T&gt;</p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QHash</a>&lt;Key,&nbsp;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMultiHash</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QHashIterator</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMutableHashIterator</a>&lt;Key,&nbsp;T&gt;</p></td></tr></tbody></table></div></div></div><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Java风格迭代器的有效位置：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><img alt="" src="C++中的容器类详解_files/0.8818864123895764.png" style="border-style: none; border-width: initial;"><br></p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面是一个典型的使用例子：&nbsp;&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QList&lt;QString&gt;&nbsp;list;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;list&nbsp;&lt;&lt;&nbsp;"A"&nbsp;&lt;&lt;&nbsp;"B"&nbsp;&lt;&lt;&nbsp;"C"&nbsp;&lt;&lt;&nbsp;"D";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QListIterator&lt;QString&gt;&nbsp;i(list);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;while&nbsp;(i.hasNext())</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;i.next();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面展示如何向后遍历</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QListIterator&lt;QString&gt;&nbsp;i(list);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;i.toBack();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;while&nbsp;(i.hasPrevious())</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;i.previous();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">如果左边有项那么hasPrevious()将返回true。previous()返回迭代器左边的项并且往前移一个位置。可以看如图：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><img alt="" src="C++中的容器类详解_files/0.39898274512961507.png" style="border-style: none; border-width: initial;"><br></p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下表是QListIterator&nbsp;的API及说明</p><div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table><tbody><tr><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Function</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Behavior</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">toFront()</a></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">迭代器移到最前，第一项的前</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">toBack()</a></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">迭代器移到最后，最后一项的后面</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">hasNext()</a></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">如果不是</span><span style="color: rgb(102, 102, 110);">list<span style="font-family: 宋体;">的最后，就返回</span>true</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">next()</a></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">返回下一项，并迭代器向后移一位</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">peekNext()</a></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">返回下一项，迭代器并不移动</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">hasPrevious()</a></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">如果不是</span><span style="color: rgb(102, 102, 110);">list<span style="font-family: 宋体;">的最前，就返回</span>true</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">previous()</a></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">返回前一项，并迭代器向后移一位</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">peekPrevious()</a></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">返回前一项，迭代器并不移动</span></p></td></tr></tbody></table></div></div></div><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面是Mutable&nbsp;iterator读写迭代器使用说明：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QList&lt;int&gt;移除基数项：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMutableListIterator&lt;int&gt;&nbsp;i(list);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;while&nbsp;(i.hasNext())&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i.next()&nbsp;%&nbsp;2&nbsp;!=&nbsp;0)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.remove();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面是QMap的迭代器示例，用法和前面是类似的：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMap&lt;QString,&nbsp;QString&gt;&nbsp;map;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map.insert("Paris",&nbsp;"France");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map.insert("Guatemala&nbsp;City",&nbsp;"Guatemala");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map.insert("Mexico&nbsp;City",&nbsp;"Mexico");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;map.insert("Moscow",&nbsp;"Russia");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMutableMapIterator&lt;QString,&nbsp;QString&gt;&nbsp;i(map);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;while&nbsp;(i.hasNext())&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i.next().key().endsWith("City"))</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.remove();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMap&lt;int,&nbsp;QWidget&nbsp;*&gt;&nbsp;map;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QHash&lt;int,&nbsp;QWidget&nbsp;*&gt;&nbsp;hash;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMapIterator&lt;int,&nbsp;QWidget&nbsp;*&gt;&nbsp;i(map);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;while&nbsp;(i.hasNext())&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.next();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash.insert(i.key(),&nbsp;i.value());</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">STL-Style:</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">STL风格是迭代器不仅支持Qt的通用算法，还兼容STL的。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">和java风格的类似，它也有两种风格的迭代器，只读的（const_iterator）和读写的（iterator）。</p><div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table><tbody><tr><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Containers</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Read-only&nbsp;iterator</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Read-write&nbsp;iterator</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QList</a>&lt;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QQueue</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QList</a>&lt;T&gt;::const_iterator</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QList</a>&lt;T&gt;::iterator</p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QLinkedList</a>&lt;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QLinkedList</a>&lt;T&gt;::const_iterator</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QLinkedList</a>&lt;T&gt;::iterator</p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QVector</a>&lt;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QStack</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QVector</a>&lt;T&gt;::const_iterator</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QVector</a>&lt;T&gt;::iterator</p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QSet</a>&lt;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QSet</a>&lt;T&gt;::const_iterator</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QSet</a>&lt;T&gt;::iterator</p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMap</a>&lt;Key,&nbsp;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMultiMap</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMap</a>&lt;Key,&nbsp;T&gt;::const_iterator</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMap</a>&lt;Key,&nbsp;T&gt;::iterator</p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QHash</a>&lt;Key,&nbsp;T&gt;,&nbsp;<a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMultiHash</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QHash</a>&lt;Key,&nbsp;T&gt;::const_iterator</p></td><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QHash</a>&lt;Key,&nbsp;T&gt;::iterator</p></td></tr></tbody></table></div></div></div><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">用过c++&nbsp;STL库的就对此很容易上手。下面是QListIterator的例子：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QList&lt;QString&gt;&nbsp;list;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;list&nbsp;&lt;&lt;&nbsp;"A"&nbsp;&lt;&lt;&nbsp;"B"&nbsp;&lt;&lt;&nbsp;"C"&nbsp;&lt;&lt;&nbsp;"D";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QList&lt;QString&gt;::iterator&nbsp;i;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;list.begin();&nbsp;i&nbsp;!=&nbsp;list.end();&nbsp;++i)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*i&nbsp;=&nbsp;(*i).toLower();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">STL风格的迭代器可允许的位置与java风格的有所不同</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><img alt="" src="C++中的容器类详解_files/0.6998029036913067.png" style="border-style: none; border-width: initial;"></p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">遍历需要我们自己增加缩减迭代器，例如：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QList&lt;QString&gt;::const_iterator&nbsp;i;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;list.constBegin();&nbsp;i&nbsp;!=&nbsp;list.constEnd();&nbsp;++i)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;*i;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QList&lt;QString&gt;&nbsp;list;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;list&nbsp;&lt;&lt;&nbsp;"A"&nbsp;&lt;&lt;&nbsp;"B"&nbsp;&lt;&lt;&nbsp;"C"&nbsp;&lt;&lt;&nbsp;"D";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QList&lt;QString&gt;::iterator&nbsp;i&nbsp;=&nbsp;list.end();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;while&nbsp;(i&nbsp;!=&nbsp;list.begin())&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--i;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*i&nbsp;=&nbsp;(*i).toLower();</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面是QMap的例子：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMap&lt;int,&nbsp;int&gt;&nbsp;map;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMap&lt;int,&nbsp;int&gt;::const_iterator&nbsp;i;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;map.constBegin();&nbsp;i&nbsp;!=&nbsp;map.constEnd();&nbsp;++i)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;i.key()&nbsp;&lt;&lt;&nbsp;":"&nbsp;&lt;&lt;&nbsp;i.value();</p><h2 style="margin-top: 0px; margin-bottom: 0px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; background-color: rgb(255, 255, 255);"><a name="t6" style="color: rgb(51, 102, 153);"></a>Foreach<span style="font-family: 黑体;">关键字</span></h2><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">下面这个用foreach去遍历QLinkedList&lt;QString&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QLinkedList&lt;QString&gt;&nbsp;list;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QString&nbsp;str;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;foreach&nbsp;(str,&nbsp;list)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;str;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">可以再循环里使用break</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QLinkedList&lt;QString&gt;&nbsp;list;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;foreach&nbsp;(const&nbsp;QString&nbsp;&amp;str,&nbsp;list)&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(str.isEmpty())</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;str;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QMap&nbsp;和&nbsp;QHash&nbsp;中，如果你想遍历键和值，你可以用iterators(更快)，或者这样写：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMap&lt;QString,&nbsp;int&gt;&nbsp;map;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;foreach&nbsp;(const&nbsp;QString&nbsp;&amp;str,&nbsp;map.keys())</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;str&nbsp;&lt;&lt;&nbsp;":"&nbsp;&lt;&lt;&nbsp;map.value(str);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">或者：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QMultiMap&lt;QString,&nbsp;int&gt;&nbsp;map;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;foreach&nbsp;(const&nbsp;QString&nbsp;&amp;str,&nbsp;map.uniqueKeys())&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(int&nbsp;i,&nbsp;map.values(str))</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qDebug()&nbsp;&lt;&lt;&nbsp;str&nbsp;&lt;&lt;&nbsp;":"&nbsp;&lt;&lt;&nbsp;i;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><h2 style="margin-top: 0px; margin-bottom: 0px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; background-color: rgb(255, 255, 255);"><a name="t7" style="color: rgb(51, 102, 153);"></a>类容器类（Container-Like&nbsp;Class<span style="font-family: 黑体;">）</span></h2><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QVarLengthArray&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">C++不支持在栈内存中提供可变长度的数组，例如下面：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">int&nbsp;myfunc(int&nbsp;n)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;table[n&nbsp;+&nbsp;1];&nbsp;&nbsp;//&nbsp;WRONG</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;table[n];</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">只能在堆内存中实现：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">int&nbsp;myfunc(int&nbsp;n)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*table&nbsp;=&nbsp;new&nbsp;int[n&nbsp;+&nbsp;1];</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;table[n];</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;table;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">但是如果myfunc在应用程序内循环中调用非常频繁，那么堆内存分配将会变得缓慢，这种情况，QT为我们提供了QVarLengthArray来解决。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">int&nbsp;myfunc(int&nbsp;n)</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;QVarLengthArray&lt;int,&nbsp;1024&gt;&nbsp;array(n&nbsp;+&nbsp;1);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;array[n];</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">值得注意的是，1.它的API是低水平的(low-level)的，他没有提供迭代器，和QVector的功能函数。2.如果值是基本类型，它将不会初始化内存。3.QVector使用隐含共享作为内存的优化，QVarLengthArray并没有提供，然而，它因为减少了经常性消费而显得性能稍微好些，特别是在紧凑的循环里。总的来说，它是为了方便用户使用在很少部分情况。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QCache&lt;Key,&nbsp;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">提供一个cache去存储Key-T键值对的对象。例如：</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QCache&lt;int,&nbsp;Employee&gt;&nbsp;cache;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">插入对象到cache</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;Employee&nbsp;*employee&nbsp;=&nbsp;new&nbsp;Employee;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;employee-&gt;setId(37);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;employee-&gt;setName("Richard&nbsp;Schmit");</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;...</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;cache.insert(employee-&gt;id(),&nbsp;employee);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QCache的好处是自动获取的对象的拥有权（ownership）。你可以指定插入对象的花费，totalCost()&nbsp;maxCost()。maxCost()默认是100。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QCache&lt;int,&nbsp;MyDataStructure&gt;&nbsp;cache(5000);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QContiguousCache&lt;T&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QContiguousCache是一个提供连续Cache存储器的模板类。和QCache不同的是，它要求一个约束——相邻（Contiguous）。这有利于用户交互界面最普遍的数据需求。这样的约束使它比QCache消耗更少的内存和处理器周期。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">简单的使用QContiguousCache的方式是使用append()&nbsp;prepend()</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;MyRecord&nbsp;record(int&nbsp;row)&nbsp;const</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;{</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q_ASSERT(row&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;row&nbsp;&lt;&nbsp;count());</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(row&nbsp;&gt;&nbsp;cache.lastIndex())</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.append(slowFetchRecord(cache.lastIndex()+1));</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(row&nbsp;&lt;&nbsp;cache.firstIndex())</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.prepend(slowFetchRecord(cache.firstIndex()-1));</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cache.at(row);</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;}</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">可以查看文档中Contiguous&nbsp;Cache&nbsp;Example的例子。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">QPair&lt;T1,&nbsp;T2&gt;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">这个在STL中也是有的（pair）用来储存键值对。它用得更多的是做为函数的返回值。</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">看下面这个例子：存储一个QString键double值的QPair</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;QPair&lt;QString,&nbsp;double&gt;&nbsp;pair;</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">使用first&nbsp;second来修改值</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;pair.first&nbsp;=&nbsp;"pi";</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;&nbsp;pair.second&nbsp;=&nbsp;3.14159265358979323846;</p><h2 style="margin-top: 0px; margin-bottom: 0px; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; background-color: rgb(255, 255, 255);"><a name="t8" style="color: rgb(51, 102, 153);"></a>算法复杂性比较</h2><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Constant&nbsp;time:&nbsp;O(1).&nbsp;常数时间复杂度</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Logarithmic&nbsp;time:&nbsp;O(log&nbsp;n).&nbsp;对数时间复杂度</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Linear&nbsp;time:&nbsp;O(n).&nbsp;线性时间复杂度</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Linear-logarithmic&nbsp;time:&nbsp;O(n&nbsp;log&nbsp;n).&nbsp;线性对数时间复杂度</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">Quadratic&nbsp;time:&nbsp;O(n<span style="font-family: 宋体;">²</span><span style="font-family: &quot;Times New Roman&quot;;">).</span>&nbsp;平方时间复杂度</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">&nbsp;顺序容器类操作时间复杂度比较：</p><div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table><tbody><tr><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Index&nbsp;lookup</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Insertion</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Prepending</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Appending</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QLinkedList</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(1)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(1)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(1)</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QList</a>&lt;T&gt;</p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(1)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(n)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QVector</a>&lt;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(1)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(n)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(n)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td></tr></tbody></table></div></div></div><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);">关联容器时间复杂度比较：</p><div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);"><div class="wiz-table-container" style="position: relative; padding: 15px 0px 5px;"><div class="wiz-table-body"><table><tbody><tr><td colspan="2" valign="middle" width="268" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);"><br></span><span style="color: rgb(49, 49, 49);">Key&nbsp;lookup</span></p></td><td colspan="3" valign="middle" width="298" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Insertion</span></p></td></tr><tr><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Average</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Worst&nbsp;case</span></p></td><td valign="middle" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Average</span></p></td><td colspan="2" valign="middle" width="205" style="background: rgb(225, 224, 224);"><p><span style="color: rgb(49, 49, 49);">Worst&nbsp;case</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMap</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QMultiMap</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(log&nbsp;</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td></tr><tr><td valign="middle" style="background: rgb(246, 246, 246);"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QHash</a>&lt;Key,&nbsp;T&gt;</p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td><td valign="middle" style="background: rgb(246, 246, 246);"><p><span style="color: rgb(102, 102, 110);">O(</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td></tr><tr><td valign="middle"><p><a target="_blank" href="http://blog.csdn.net/xuguangsoft/article/details/8514921" style="color: rgb(51, 102, 153); text-decoration: none;">QSet</a>&lt;Key&gt;</p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">O(</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p></td><td valign="middle"><p><span style="color: rgb(102, 102, 110);">Amort.&nbsp;O(1)</span></p></td><td valign="middle" class=""><p><span style="color: rgb(102, 102, 110);">O(</span><span style="color: rgb(102, 102, 110);">n</span><span style="color: rgb(102, 102, 110);">)</span></p><br><div style="color:gray"><small>来源：&nbsp;<a href="http://blog.csdn.net/taiyang1987912/article/details/50351827">http://blog.csdn.net/taiyang1987912/article/details/50351827</a></small></div></td></tr></tbody></table></div></div></div></body></html>